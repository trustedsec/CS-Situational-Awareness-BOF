%recordmapping = %(
A => 1,
NS => 2,
MD => 3,
MF => 4,
CNAME => 5,
SOA  => 6,
MB  => 7,
MG => 8,
MR => 9,
WKS => 0xb,
PTR => 0xc,
HINFO => 0xd,
MINFO => 0xe,
MX => 0xf,
TEXT => 0x10,
RP => 0x11,
AFSDB => 0x12,
X25 => 0x13,
ISDN => 0x14,
RT => 0x15,
AAAA => 0x1c,
SRV => 0x21,
WINSR => 0xff02,
KEY => 0x0019,
ANY => 0xff);

%enumtype = %(
all => 1,
locked => 2,
disabled => 3,
active => 4);

%reghives = %(
HKCR => 0,
HKCU => 1,
HKLM => 2,
HKU  => 3);
#sleep can't handle the actual values... so we'll just add them on the c side :(

%regtypes = %(
REG_SZ => 1,
REG_EXPAND_SZ => 2,
REG_BINARY => 3,
REG_DWORD => 4,
REG_MULTI_SZ => 7,
REG_QWORD => 11);

%inttypes = %( 
	REG_DWORD => 1, 
	REG_QWORD => 1);

# subrotine to parse options for script.
# Returns optios as a hash
sub ops {
	local('$count');
	$count = 0;
	%arguments = ohash();
	foreach $arg ($1) {
		if ($count > 0) {
			if ($arg ismatch '/.*:.*') {
				$arg = replace($arg, '\A/',"");
				($key, $val) = split(":", $arg, 2);
				%arguments[$key] = $val;
			}
			else if ($arg ismatch '/.*') {
				$arg = replace($arg, '\A/',"");
				%arguments[$arg] = "TRUE";
			}
			else {
				%arguments["$count"] = $arg;
			}
		}
		$count = $count + 1;
	}
	return (%arguments);
}


sub readbof {
	local('$barch $handle $data $msg $ttp');
	$barch  = barch($1);

	# read in the right BOF file
    println(script_resource("$2 $+ / $+ $2 $+ . $+ $barch $+ .o"));
	$handle = openf(script_resource("$2 $+ / $+ $2 $+ . $+ $barch $+ .o"));
	$data   = readb($handle, -1);
	closef($handle);
	if(strlen($data) == 0)
	{
		berror($1, "could not read bof file");
	}
	
	$ttp = iff( ($4 eq $null || $4 eq ""), "", $4);
	$msg = iff( ($3 eq $null || $3 eq ""), "Running $2", $3);
	$msg = iff( ($ttp ne $null && $ttp ne ""), $msg . " (" . $ttp . ")", $msg);
	# announce what we're doing
	blog($1, $msg);
	btask($1, $msg, $ttp);
	return $data;
}


alias dir {
	local('$params $keys $args $targetdir $subdirs $ttp $text');

	%params = ops(@_);
	@keys = keys(%params);

	$targetdir = ".\\";
	$subdirs = 0;

	if ("s" in @keys) {
		$subdirs = 1;
	}
	if ("1" in @keys) {
		$targetdir = %params["1"];
	}

	if(left($2, 2) eq "\\\\") {
		$ttp = "T1135";
		$text = "Issuing remote dir to $targetdir";
	} else {
		$ttp = "T1083";
		$text = "Issuing local dir to $targetdir";
	}

	$args = bof_pack($1, "zs", $targetdir, $subdirs);
	beacon_inline_execute($1, readbof($1, "dir", $msg, $ttp), "go", $args);
}

beacon_command_register(
	"dir",
	"Lists a target directory using BOF.",
	"Usage: dir [directory] [/s]"
);


beacon_command_register(
"env", 
"Print environment variables.", 
"env - Print environment variables for current process");

alias env {
	# execute it.
	beacon_inline_execute($1, readbof($1, "env", $null, "T1082"), "go");
}

beacon_command_register(
"ldapsearch", 
"BOF - Perform LDAP search.", 
"ldapsearch <query> [--attributes] [--count] [--scope] [--hostname] [--dn] [--ldaps]
	with :
		query => the LDAP query to be performed
		--attributes [comma_separated_attributes] => the attributes to retrieve (default: *)
		--count [count] => the result max size (default: None)
		--scope [scope] => the scope to use [1 = BASE, 2 = LEVEL, 3 = SUBTREE] (default: 3)
		--hostname [hostname] => hostname or IP to perform the LDAP connection on (default: automatic DC resolution)
		--dn [dn] => the LDAP query base
		--ldaps => use of ldaps

Important - To add in ACLs so Bloodhound can draw relationships between objects (see external BofHound tool), add nTSecurityDescriptor in the attributes list, like so:
ldapsearch <query> --attributes *,ntsecuritydescriptor ...
Useful queries (queries are just an example, edit where necessary to make it OPSEC safe):

- Kerberoastable:\n(&(samAccountType=805306368)(servicePrincipalName=*)(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))

- AS-REP Roastable:\n(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))

- Passwords stored with reversible encryption:\n(&(objectClass=user)(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=128))

If this fails with an error about paging not being supported you can try to use nonpagedldapsearch instead (its unregistered but has the same arguments)");

alias ldapsearch {
	local('$args $attributes $result_limit $scope $hostname $domain');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("ldapsearch"));
		return;
	}


	$ldapsearch_len = 11;
	$query_len = strlen($2) + 1;
	$total_mandatory_len = $ldapsearch_len + $query_len;
	$base_len = strlen($0);

	if($base_len > $total_mandatory_len){
		$data = substr($0, $total_mandatory_len);
		@args = split('--', $data);
	}
	else{
		@args = @();
	}

	local('$query $attributes $scope $hostname $dn $ldaps');

	$query = replaceQuotes($2);
	$attributes = "*";
	$result_limit = 0;
	$scope = 3;
	$hostname = "";
	$dn = "";
	$ldaps = 0;

    for ($i = 1; $i < size(@args); $i++) {
        $arg = @args[$i];
		$option = split(' ', $arg)[0];
		$value = substr($arg, strlen($option));
		$value = replaceQuotes($value);

        if ($option iswm "attributes") {
            $attributes = $value;
        }
        else if ($option iswm "count") {
            $result_limit = $value;
        }
        else if ($option iswm "scope") {
            $scope = $value;
        }
        else if ($option iswm "hostname") {
            $hostname = $value;
        }
        else if ($option iswm "dn") {
            $dn = $value;
        }
        else if ($option iswm "ldaps") {
            $ldaps = 1;
        }
		else{
			berror($1, "Unknown argument: " . $arg);
			berror($1, beacon_command_detail("ldapsearch"));
			return;
		}
	}

	$args   = bof_pack($1, "zziizzi", $query, $attributes, $result_limit, $scope, $hostname, $dn, $ldaps);

	# execute it.
	beacon_inline_execute($1, readbof($1, "ldapsearch", $null, "T1018, T1069.002, T1087.002, T1087.003, T1087.004, T1482"), "go", $args);
}

# Helper function to remove surrounding quotes and spaces
sub replaceQuotes {
    local('$str');
	$str = $1;
    $str = trim($str);
    if ($str ismatch"^\".*\"$" || $str ismatch "^'.*'$") {
        return substr($str, 1, size($str) - 1);
    }
    return $str;
}

# Helper function to trim spaces
sub trim {
    local('$str');
	$str = $1;
    $str = replace($str, "^\\s+", "");
    $str = replace($str, "\\s+$", "");
    return $str;
}


alias nonpagedldapsearch
{
	local('$args $attributes $result_limit $hostname $domain');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("ldapsearch"));
		return;
	}

	$attributes = iff(-istrue $3, $3, "");
	$result_limit = iff(-istrue $4, $4, 0);
	$hostname = iff(-istrue $5, $5, "");
	$domain = iff(-istrue $6, $6, "");

	$args   = bof_pack($1, "zzizz", $2, $attributes, $result_limit, $hostname, $domain);

	# execute it.
	beacon_inline_execute($1, readbof($1, "nonpagedldapsearch", $null, "T1018, T1069.002, T1087.002, T1087.003, T1087.004, T1482"), "go", $args);
}

alias ipconfig {

	beacon_inline_execute($1, readbof($1, "ipconfig", $null, "T1016"), "go", $null);
}

beacon_command_register(
"ipconfig", 
"runs an internal ipconfig command", 
"Synopsis: ipconfig \n\nLists out adapters, system hostname and configured dns server");


alias arp {
	beacon_inline_execute($1,readbof($1,'arp', $null, "T1016, T1018"),"go",$null);
}

beacon_command_register("arp", 
"Runs an internal ARP command", 
"Synopsis: arp \n\nLists out ARP table");

alias nslookup {
	local('$args $barch $lookup $server $type');
	
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("nslookup"));
		return;
	}
	$barch  = barch($1);
	$lookup = $2;
	$server = iff(-istrue $3, $3, "");
	$type = iff(-istrue $4, iff(uc($4) in %recordmapping, %recordmapping[uc($4)], %recordmapping["A"]) , %recordmapping["A"]);
	btask($1, $server);
	if($server eq "127.0.0.1"){
		berror($1, "Localhost dns query's have a potential to crash, refusing");
		return;
	}
	if($barch eq "x86"){
	btask($1, "x86 beacons do not support custom dns nameservers, overriding to default");
	$server = "";
	}
	$args = bof_pack($1, "zzs", $lookup, $server, $type);
	beacon_inline_execute($1, readbof($1, "nslookup", "Attempting to resolve $lookup", "T1018"), "go", $args);
}

beacon_command_register(
	"nslookup", 
	"internally perform a dns query", 
	"Synopsis: nslookup <lookup value> <lookup server> <TYPE> \n\nPerform a DNS Query:\n<lookup value> is the ip or hostname you want to query\n<lookup server> is the server you want to query (use 0 or exclude for system default)\n<TYPE> record type to query");

alias netview {
	local('$args $domain');

	$domain = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $domain);
	beacon_inline_execute($1, readbof($1, "netview", $null, "T1018"), "go", $args);
}

beacon_command_register(
	"netview",
	"lists local workstations and servers",
	"Synopsis: netview <optional netbios domain name>
	
hint: use netview_list if you want to map shares of a remote machine"
);

alias listdns {

	beacon_inline_execute($1, readbof($1, "listdns", $null, $null), "go", $null);
}

beacon_command_register(
	"listdns",
	"lists dns cache entries",
	"Synopsis: listdns (does not take arguments)  Note this will query each found hostname for its ip address"
);

alias listmods {
	local('$args $pid');

	$pid = iff(-istrue $2, $2, 0);
	$args = bof_pack($1, "i", $pid);
	beacon_inline_execute($1, readbof($1, "listmods", $null, $null), "go", $args);
}

beacon_command_register(
	"listmods",
	"lists process modules",
	"Synopsis: listmods <opt: pid> "
);

alias locale {
	btask($1, "Retrieving system locale information", "T1614, T1614.001");
	beacon_inline_execute($1,readbof($1,'locale'),"go",$null);
}

beacon_command_register("locale", 
"Retrieve System Locale Information, Date Format, and Country", 
"Synopsis: locale \n\nPrints locale information");

alias notepad {
	btask($1, "Searching for open notepad windows", "T1552");
	beacon_inline_execute($1,readbof($1,'notepad'),"go",$null);
}

beacon_command_register("notepad", 
"Search for open notepad and notepad++ windows and grab text from the editor control object", 
"Synopsis: notepad \n\nPrints any observed open notepad or notepad++ sessions and prints their contents. Not reliant on clipboard. Not reliant on window being non-minimized");

alias netuse_add {
	local('$args $device $share $user $password $persist $requireencrypt %params');

	if(size(@_) < 4)
	{
		berror($1, beacon_command_detail("netuse_add"));
		return;
	}
	$share = $2;
	$user = $3;
	$password = $4;
	$persist = 0;
	$requireencrypt = 0;
	%params = ops(@_);
	@keys = keys(%params);
	$device = "";
	if("PERSIST" in @keys) { $persist = 1; }
	if("REQUIREPRIVACY" in @keys) {$requireencrypt = 1; }
	if("DEVICE" in @keys) { $device = %params["DEVICE"] . ":"; }

	$args = bof_pack($1, "sZZZZss", 1, $share, $user, $password, $device, $persist, $requireencrypt);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1570, T1021.002"), "go", $args);


}

beacon_command_register(
	"netuse_add",
	"Connect to a shared resource",
	"
Command: netuse_add
Summary: This command connects a computer to a shared resource.
Usage:   netuse_add (sharename) [opt:username] [opt:password] [opt:/DEVICE:devicename] [opt:/PERSIST] [opt:/REQUIREPRIVACY]
		 sharename	  Required. The network name of the shared resource to 
						connect to.
		username	   Required. The username to use for the remote connection, uses process auth if not provided.
		password	   Required. The password to use for the remote connection, default password for <username> used if not provided.
		/DEVICE:<devname>	 Optional. The device name on the local system to list, 
		  bind the connection to.  Does not bind a device if not given
		  ex. /DEVICE:Y
		/PERSIST		Optional flag. Persist the connection.
		/REQUIREPRIVACY      Optional. require SMBv3 Encryption, fail if not supported.
Example:
	Bind IPC$ of a remote computer using current user context
		netuse_add \\\\somedc.somedomain.local\\IPC$ \"\" \"\"

	Map a Share without creating a specific device mapping using current user context 
		netuse_add \\\\fileshare.somedomain.local\\adminstuff \"\" \"\"

	Map a Share without creating a specific device mapping, using a diferent set of credentials
		netuse_add \\\\fileshare.somedomain.local\\adminstuff someuser SomeUsersPassword /DEVICE:F

	Map a persistent share in the current user context
		netuse_add \\\\fileshare.somedomain.local\\userdrive \"\" \"\" /PERSIST
"
);

alias netuse_list {
	local('$args $target');
	if(size(@_) > 2)
	{
		berror($1, beacon_command_detail("netuse_list"));
		return;
	}
	$target = "";
	if(size(@_) == 2)
	{
		$len = strlen($2);
		$target = iff($len == 1, $2 . ":", $2);
		if($len > 2) #Remote share name was given, correct target
		{
			$target = iff(left($2, 2) eq "\\\\", $2, "\\\\" . $2);
		}
	}
	$args = bof_pack($1, "sZ", 2, $target);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netuse_list",
	"Lists local bound connections",
	"
Command: netuse_list
Summary: This command lists bound connections when run without arguments.
		 It a specific connection when a device or remote share name is given
Usage:   netuse_list [opt:device || share]

Examples:
	List local connections:
		netuse_list

	List all info about Y:
		netuse_list Y:
"
);

alias netuse_delete {
	local('$args $target $len $persist $force');
	if(size(@_) < 2)
	{
		berror($1, beacon_command_detail("netuse_delete"));
		return;
	}
	$len = strlen($2);
	$target = iff($len == 1, $2 . ":", $2);
	if($len > 2) #Remote name was given correct target
	{
		$target = iff(left($2, 2) eq "\\\\", $2, "\\\\" . $2);
	}
	$persist = 0;
	$force = 0;
	%params = ops(@_);
	@keys = keys(%params);
	if("PERSIST" in @keys) { $persist = 1; }
	if("FORCE" in @keys) {$force = 1;}
	$args = bof_pack($1, "sZss", 3, $target, $persist, $force);
	beacon_inline_execute($1, readbof($1, "netuse", $null, "T1570, T1021.002"), "go", $args);
}

beacon_command_register(
	"netuse_delete",
	"disconnects from a shared resource",
	"
Command: netuse_delete
Summary: This command disconnects a computer from a shared resource.
Usage:   netuse_delete (devicename || sharename) [opt:/PERSIST] [opt:/FORCE]

	/PERSIST | Delete persistent connections so they are not restored
	/FORCE | force resource to unmap even if resources are open

Examples:
	Delete the share with the local device name Y:
		netuse_delete Y

	Delete the share with an unmapped local device name
		netuse_delete \\\\fileshare.somecomp.local\\Public

	Delete a share and remove its persistent mapping
		netuse_delete F /PERSIST

Note if the share has a local device name mapped you must delete using the local name
"
);


alias netuser {
	local('$args $domain');
	if(size(@_) < 2){
		berror($1, beacon_command_detail("netuser"));
		return;
	}
	$domain = iff(-istrue $3, $3, "");
	$args = bof_pack($1, "ZZ", $2, $domain);
	beacon_inline_execute($1, readbof($1, "netuser", $null, "T1087.001"), "go", $args);
}

beacon_command_register(
	"netuser",
	"list user info",
	"Synopsis: netuser <username> <optional: dns or netbios domain name, if not given run against local computer>"
);

alias windowlist {
	beacon_inline_execute($1, readbof($1, "windowlist", $null, "T1010"), "go", bof_pack($1, "i", iff($2 eq "all", 1, 0)));
}

beacon_command_register(
	"windowlist",
	"list visible windows",
	"Synopsis: List windows visible on the users desktop
	optionally specify \"all\" as an argument to see every possible window"
);

alias netstat {
	beacon_inline_execute($1, readbof($1, "netstat", $null, "T1049"), "go", $null);
}

beacon_command_register(
	"netstat",
	"get local ipv4 udp/tcp listening and connected ports",
	"Synopsis: List listening and connected ipv4 udp and tcp connections"
);

alias routeprint {
	beacon_inline_execute($1, readbof($1, "routeprint", $null, "T1016"), "go", $null);
}

beacon_command_register(
	"routeprint",
	"prints ipv4 routes on the machine",
	"Synopsis: Lists targets ipv4 routes"
);

alias whoami {
	beacon_inline_execute($1, readbof($1, "whoami", $null, "T1033"), "go", $null);
}

beacon_command_register (
	"whoami",
	"internal version of whoami /all",
	"run this to get the info from whoami /all without starting cmd.exe"
);

alias userenum {
	local('$args $type');
	if(size (@_) == 2)
	{
		if(@_[1] in %enumtype)
		{
			$type = %enumtype[@_[1]];
		}
		else{
			berror($1, beacon_command_detail("userenum"));
			berror($1, "Invalid filter specified");
			return;
		}
	}
	else{
		$type = %enumtype["all"];
	}
	$args = bof_pack($1, "ii", 0, $type);
	beacon_inline_execute($1, readbof($1, "netuserenum", $null, "T1087.001"), "go", $args);
}

alias domainenum {
	local('$args $type');
	if(size (@_) == 2)
	{
		if(@_[1] in %enumtype)
		{
			$type = %enumtype[@_[1]];
		}
		else{
			berror($1, beacon_command_detail("domainenum"));
			berror($1, "Invalid filter specified");
			return;
		}
	}
	else{
		$type = %enumtype["all"];
	}
		$args = bof_pack($1, "ii", 1, $type);
	beacon_inline_execute($1, readbof($1, "netuserenum", $null, "T1087.002"), "go", $args); # netuserenum here is not a mistake
}

beacon_command_register(
	"domainenum",
	"list usersaccounts in the current domain",
	"This command lists out domain user accounts
	You may specify one of (all, active, locked, disabled) to filter accounts returned
	defaults to all if not specified;"
);

beacon_command_register(
	"userenum",
	"List computer user accounts",
	"This command lists user accounts on the current computer
	You may specify one of (all, active, locked, disabled) to filter accounts returned
	defaults to all if not specified;"
);

alias driversigs {
	beacon_inline_execute($1, readbof($1, "driversigs", $null, "T1518.001"), "go", $null);
}

beacon_command_register(
	"driversigs",
	"checks drivers for known edr vendor names",
	"Run the command and we will accept enumerate services and check the binary signatures for known edr vendor names"
);

alias netshares{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netshares", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netshares",
	"list shares on local or remote computer",
	"netshares <\\computername>"
);

alias netsharesAdmin{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 1);
	beacon_inline_execute($1, readbof($1, "netshares", $null, "T1135"), "go", $args);
}

beacon_command_register(
	"netsharesAdmin",
	"list shares on local or remote computer and gets more info then standard netshares(requires admin)",
	"netsharesAdmin <\\computername>"
);

sub bnetgroup{
	local('$args $domain $group $type');
	$type = $2;
	if($type < 0 || $type > 1)
	{
		berror($1, "Invalid type passed to bnetgroup");
		return;
	}
	if($type == 1) #list group members
	{
		$group = $3;
		$domain = iff(-istrue $4, $4, "");
	}
	else # list groups
	{
		$group = "";
		$domain = iff(-istrue $3, $3, "");
	}
	$args = bof_pack($1, "sZZ", $type, $domain, $group);
	beacon_inline_execute($1, readbof($1, "netgroup", $null, "T1069.002"), "go", $args);
}

alias netGroupList {
	bnetgroup($1, 0, $2);
}

alias netGroupListMembers {
	bnetgroup($1, 1, $2, $3);
}

beacon_command_register(
	"netGroupList",
	"List Groups in this domain (or specified domain if given)",
	"netGroupList: <opt: domainname>"
);

beacon_command_register(
	"netGroupListMembers",
	"List the members of the specified group in this domain (or specified domain if given)",
	"netGroupListMembers: <Group Name> <opt: domainname>"
);

sub bnetlocalgroup{
	local('$args $server $group $type');
	$type = $2;
	if($type < 0 || $type > 1)
	{
		berror($1, "Invalid type passed to bnetlocalgroup");
		return;
	}
	if($type == 1) #list group members
	{
		$group = $3;
		$server = iff(-istrue $4, $4, "");
	}
	else # list groups
	{
		$group = "";
		$server = iff(-istrue $3, $3, "");
	}
	$args = bof_pack($1, "sZZ", $type, $server, $group);
	beacon_inline_execute($1, readbof($1, "netlocalgroup", $null, "T1069.001"), "go", $args);
}

alias netLocalGroupList {
	bnetlocalgroup($1, 0, $2);
}

alias netLocalGroupListMembers {
	bnetlocalgroup($1, 1, $2, $3);
}

beacon_command_register(
	"netLocalGroupList",
	"List Groups in this server (or specified server if given)",
	"netGroupList: <opt: servername>"
);

beacon_command_register(
	"netLocalGroupListMembers",
	"List the members of the specified group in this server (or specified server if given)",
	"netGroupListMembers: <Group Name> <opt: servername>"
);

sub bnetlocalgroup2{
	local('$args $server $group');
	
	$group = iff(-istrue $2, $2, "");
	$server = iff(-istrue $3, $3, "");
	
	$args = bof_pack($1, "ZZ", $server, $group);
	beacon_inline_execute($1, readbof($1, "netlocalgroup2", $null, "T1069.001"), "go", $args);
}

alias netLocalGroupListMembers2 {
	bnetlocalgroup2($1, $2, $3);
}

beacon_command_register(
	"netLocalGroupListMembers2",
	"List the members of the specified group in this server (or specified server if given). Output is compatible with bofhound",
	"netLocalGroupListMembers2: <opt: Group Name> <opt: servername>
	use \"\" for group name to query all interesting local groups
		
Note: Output from this BOF is compatible with bofhound"
);

sub bschtasksenum{
	local('$args');
	$args = bof_pack($1, "Z", iff(-istrue $2, $2, ""));
	beacon_inline_execute($1, readbof($1, "schtasksenum", $null, $null), "go", $args);		# while T1053.005 exists, it is related to use not discovery
}

alias schtasksenum{
	bschtasksenum($1, $2);
}

beacon_command_register(
	"schtasksenum",
	"enumerates all scheduled tasks on the local or target machine",
	"schtasksenum <opt:target>"
);


sub bschtasksquery{
	local('$args');
	$args = bof_pack($1, "ZZ", $2, $3);
	beacon_inline_execute($1, readbof($1, "schtasksquery", $null, $null), "go", $args);
}


alias schtasksquery{
	local('$server $taskname');
	$server = "";
	if ( size(@_) < 2)
	{
		berror($1, "Invalid Usage");
		berror($1, beacon_command_detail("schtasksquery"));
		return;
	} else if(size(@_) == 2)
	{
		$taskname = $2;
	} else if(size(@_) == 3)
	{
		$server = $2;
		$taskname = $3;
	} else 
	{
		berror($1, "Invalid Usage");
		berror($1, beacon_command_detail("schtasksquery"));
		return;
	}
	bschtasksquery($1, $server, $taskname);
}

beacon_command_register(
	"schtasksquery",
	"lists the details of the requested task",
	"schtasksquery <opt:server> <taskname>
	Note the task name must be given by full path including taskname, ex. 
	schtasksquery \\Microsoft\\Windows\\MUI\\LpRemove"
);

sub bcacls{
	beacon_inline_execute($1, readbof($1, "cacls", $null, $null), "go",  bof_pack($1, "Z", $2));			# while T1222 exists, it is for changing them not discovering them
}

alias cacls{
	if( size(@_) < 2)
	{
		berror($1, "requires file path");
		berror($1, beacon_command_detail("cacls"));
		return;
	}
	bcacls($1, $2);
}

beacon_command_register(
	"cacls",
	"lists file permissions",
	"cacls <file path>
	Wildcards are supported
	ex
		cacls C:\\windows\\system32\\*
		cacls C:\\windows\\system32\\cmd.exe
	Key:
		F: Full access
		R: Read & Execute access
		C: Read, Write, Execute, Delete
		W: Write access"
);

alias sc_query {
	local('$hostname $servicename $args');
	$hostname = $null;
	$servicename = $null;

	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}

	$args = bof_pack($1, "zz", $hostname, $servicename);
	beacon_inline_execute($1, readbof($1, "sc_query", $null, "T1007"), "go", $args);

}

beacon_command_register(
	"sc_query", 
	"queries a services status", 
	"Synopsis: sc_query <opt: service name> <opt: hostname>
give no parameters to enumerate all services
Give just a service name to query just that service
Give \"\" as the service name and a remote host to enumerate all services on a remote host
Give both to query a specific service on a remote host"
);

alias sc_qc {
	local('$hostname $servicename $args');


	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qc"));
		return;
	}


	$args = bof_pack($1, "zz", $hostname, $servicename);
	beacon_inline_execute($1, readbof($1, "sc_qc", $null, "T1007"), "go", $args);
}

beacon_command_register(
	"sc_qc", 
	"queries a services configuration", 
	"Synopsis: sc_qc  <service name> <opt: hostname>
	 hostname is optional, and the local system is targeted if it is not found"
);


alias sc_qdescription {
	local('$hostname $servicename $args');

	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qdescription"));
		return;
	}

		$args = bof_pack($1, "zz", $hostname, $servicename);
		beacon_inline_execute($1, readbof($1, "sc_qdescription", $null, "T1007"), "go", $args);

}

beacon_command_register(
	"sc_qdescription", 
	"queries a services description", 
	"Synopsis: sc_qdescription <service name> <opt: hostname>
	hostname is optional, and the local system is targeted if it is not found");

#2 = hostname
#3 = servicename
sub bsc_qfailure{
	beacon_inline_execute($1, readbof($1, "sc_qfailure", $null, "T1007"), "go", bof_pack($1, "zz", $2, $3));
}

alias sc_qfailure{
	local('$hostname $servicename $args');
	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qfailure"));
		return;
	}

	bsc_qfailure($1, $hostname, $servicename);
}

beacon_command_register(
	"sc_qfailure",
	"list service failure actions",
	"usage: sc_qfailure [servicename] [opt: hostname]"
);

sub bsc_qtriggerinfo{
	beacon_inline_execute($1, readbof($1, "sc_qtriggerinfo", $null, "T1007"), "go", bof_pack($1, "zz", $2, $3));
}

alias sc_qtriggerinfo{
	local('$hostname $servicename $args');
	if(size(@_) == 2)
	{
		$servicename = $2;
		$hostname = $null;
	}
	else if (size(@_) == 3)
	{
		$servicename = $2;
		$hostname = $3;
	}
	else
	{
		berror($1, beacon_command_detail("sc_qtriggerinfo"));
		return;
	}

	bsc_qtriggerinfo($1, $hostname, $servicename);
}

beacon_command_register(
	"sc_qtriggerinfo",
	"lists service triggers",
	"usage: sc_qtriggers [servicename] [opt: hostname]"
);


alias sc_enum{
	#$2 = NULL if not given which is what makes this ok
	beacon_inline_execute($1, readbof($1, "sc_enum", $null, "T1007"), "go", bof_pack($1, "z", $2));
}

beacon_command_register(
	"sc_enum",
	"Enumerate all service configs in depth",
	"usage: sc_enum [opt: hostname]"
);

alias reg_query
{
	#I need hostname Hive, path, key type value(s)
	#test if val in pos 1 is in Hive, if not, then assume it is a hostname
	# values at end, if multisz pack them using a variable bof string
	local('$hostname $hive $path $key $i');
	$packstr = "zizz";
	if(size(@_) < 3){
		berror($1, beacon_command_detail("reg_query"));
		return;
	}
	else{
		if($2 in %reghives)
		{
			#targeting local system
			$hostname = $null;
			$i = 1;
		}
		else{
			$hostname = "\\\\" . $2;
			$i = 2;
		}
		if (@_[$i] in %reghives)
		{
			$hive = %reghives[@_[$i]];
			$i++;
		}
		else
		{
			berror($1, beacon_command_detail("reg_query"));
			berror($1, "Provided registry hive value is invalid");
			return;
		}
		$path = @_[$i];
		println($path);
		$i++;
		if($i < size(@_))
		{
			$key = @_[$i];
			println("set subkey value to $key");
		}
		else
		{
			$key = "";
		}
		$args = bof_pack($1, "zizzi", $hostname, $hive, $path, $key, 0);
		beacon_inline_execute($1, readbof($1, "reg_query", $null, $null), "go", $args);			#T1060 exists but is about setting run keys, no broader TTP exists and none for discovery
	}

}
beacon_command_register(
	"reg_query",
	"querys registry Key OR value",
"<opt:hostname> <hive> <path> <opt: value to query>
hive should be one of:
	HKLM
	HKCU
	HKU
	HKCR
If a value to query is not specified, that one key is enumerated");

alias reg_query_recursive{
	local('$hostname $hive $path $i');
	$packstr = "zizz";
	if(size(@_) < 3){
		berror($1, beacon_command_detail("reg_query_recursive"));
		return;
	}
	else{
		if($2 in %reghives)
		{
			#targeting local system
			$hostname = $null;
			$i = 1;
		}
		else{
			$hostname = "\\\\" . $2;
			$i = 2;
		}
		if (@_[$i] in %reghives)
		{
			$hive = %reghives[@_[$i]];
			$i++;
		}
		else
		{
			berror($1, beacon_command_detail("reg_query_recursive"));
			berror($1, "Provided registry hive value is invalid");
			return;
		}
		$path = @_[$i];
		println($path);
		$i++;
		$args = bof_pack($1, "zizzi", $hostname, $hive, $path, "", 1);
		beacon_inline_execute($1, readbof($1, "reg_query", $null, $null), "go", $args);
	}
}

beacon_command_register(
	"reg_query_recursive",
	"recursivly querys registry key",
"<opt:hostname> <hive> <path> 
hive should be one of:
	HKLM
	HKCU
	HKU
	HKCR
If a value to query is not specified, that one key is enumerated");


alias tasklist{
	local('$args $resource');

	$resource = "";

	if ((size(@_) < 1) || (size(@_) > 2))
	{
		berror($1, beacon_command_detail("tasklist"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$resource = iff(-istrue $2, "\\\\$2\\root\\cimv2", "\\\\.\\root\\cimv2");
	$args = bof_pack($1, "Z", $resource);
	beacon_inline_execute($1, readbof($1, "tasklist", "Connecting to $resource and retrieving list of currently running processes", "T1057"), "go", $args);
}

beacon_command_register(
	"tasklist",
	"Lists currently running processes",
	"
Command: tasklist
Summary: This command displays a list of currently running processes on either
		 a local or remote machine.
Usage:   tasklist (system)
		 system	   - Optional. Specifies the remote system to connect to. Do
						not include or use '.' to indicate the command should
						be run on the local system.
Note:	You must have a valid login token for the system specified if not
		 local. This token can be obtained using make_token.
"
);


alias wmi_query{
	local('$query $system $namespace $resource $args');

	if ((size(@_) < 2) || (size(@_) > 4))
	{
		berror($1, beacon_command_detail("wmi_query"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$query = $2;
	$system = iff(-istrue $3, $3, ".");
	$namespace = iff(-istrue $4, $4, "root\\cimv2");
	$resource = "\\\\" . $+ . $system . $+ . "\\" . $+ . $namespace;

	$args = bof_pack($1, "ZZZZ", $system, $namespace, $query, $resource);
	beacon_inline_execute($1, readbof($1, "wmi_query", "Connecting to \\\\$system\\$namespace and running the WMI query \'$query\'", $null), "go", $args);			#T1047 exists but is about execution, not discovery
}

beacon_command_register(
	"wmi_query",
	"Runs a general WMI query",
	"
Command: wmi_query
Summary: This command runs a general WMI query on either a local or remote
		 machine and displays the results in a comma separated table.
Usage:   wmi_query [query] (system) (namespace)
		 query		- The query to run. The query should be in WQL.
		 system	   - Optional. Specifies the remote system to connect to. Do
						not include or use '.' to indicate the command should
						be run on the local system.
		 namespace	- Optional. Specifies the namespace to connect to. This
						defaults to root\\cimv2 if not specified.
Note:	You must have a valid login token for the system specified if not
		 local. This token can be obtained using make_token.
"
);


alias netsession {
	local('$args $hostname');

	$args = bof_pack($1, "Z", $2);
	beacon_inline_execute($1, readbof($1, "get-netsession", $null, "T1049"), "go", $args);     #T1049 is a loose match
}

beacon_command_register(
	"netsession",
	"list sessions on server",
	"Synopsis: netsession <computer> "
);

alias netsession2 {
	local('$args $hostname $method $dnsserver');

	$hostname = iff(-istrue $2, $2, "");
	$method = iff(-istrue $3, $3, 1);
	$dnsserver = iff(-istrue $4, $4, "");

	$args = bof_pack($1, "Zsz", $hostname, $method, $dnsserver);
	beacon_inline_execute($1, readbof($1, "get-netsession2", $null, "T1049"), "go", $args);     #T1049 is a loose match
}

beacon_command_register(
	"netsession2",
	"list sessions on server. Output is compatible with bofhound",
	"Usage: netsession2 <opt: computer> <opt: Resolution Method> <opt: DNS Server>
	Resolution methods: 
		1 = DNS (Default)
		2 = NetWkstaGetInfo

Note: Output from this BOF is compatible with bofhound"
);



alias resources {
	beacon_inline_execute($1, readbof($1, "resources", $null, "T1082"), "go", $null);
}

beacon_command_register(
"resources",
"List available memory and space on the primary disk drive",
"Usage: resources");


alias uptime {
	beacon_inline_execute($1, readbof($1, "uptime", $null, "T1082"), "go", $null);
}

beacon_command_register(
"uptime",
"Lists system boot time",
"Usage: uptime");



alias useridletime {
	beacon_inline_execute($1, readbof($1, "useridletime", $null, "T1082"), "go", $null);
}

beacon_command_register(
"useridletime",
"Shows the user's idle time",
"Usage: useridletime");



alias enum_filter_driver{
	local('$args $system');

	$system = "";

	if ((size(@_) < 1) || (size(@_) > 2))
	{
		berror($1, beacon_command_detail("enum_filter_driver"));
		berror($1, "Invalid number of arguments");
		return;
	}
	$system = iff(-istrue $2, $2, $null);
	$args = bof_pack($1, "z", $system);
	beacon_inline_execute($1, readbof($1, "enum_filter_driver", "Retrieving list of filter drivers", "T1518.001"), "go", $args);
}

beacon_command_register(
	"enum_filter_driver",
	"Lists filter drivers on the system",
	"
Command: enum_filter_driver
Summary: This command displays a list of filter drivers installed on the 
         system. The results are returned in a CSV format with the type, name,
         and altitude number.
Usage:   enum_filter_driver <opt:system>
         system    Optional. Specifies the remote system to connect to. Do not 
                   include a system argument to indicate the command should be 
                   run on the local system.
Note:    You must have a valid login token for the system specified if not 
         local. This token can be obtained using make_token.
"
);



alias adv_audit_policies{
	local('$iswow64');
		
	$iswow64 = iff(-is64 $1 && barch($1) eq "x86", 1, 0);

	beacon_inline_execute($1, readbof($1, "adv_audit_policies", "Retrieving advanced security audit policies... iswow64: $iswow64", $null), "go", bof_pack($1, "i", $iswow64));
}

beacon_command_register(
	"adv_audit_policies",
	"Retrieves advanced security audit policies",
	"
Command: adv_audit_policies
Summary: This command retrieves the advanced security audit policies set in the
         group policy of the local system and/or domain.
Usage:   adv_audit_policies
"
);

alias listpipes
{
	btask($1, "Listing Named Pipes", "DS0023");
	bls($1, "//./pipe/");
}

beacon_command_register(
	"listpipes",
	"Lists local named pipes",
	"Usage: listpipes"
);
alias enumLocalSessions{
	beacon_inline_execute($1, readbof($1, "enumlocalsessions", $null, "T1033"), "go", $null);
}

beacon_command_register(
	"enumLocalSessions",
	"Enumerate the currently attached user sessions both local and over rdp",
	"Usage: enumLocalSessions"
);

alias findLoadedModule{
	local('$iswow64 $modname $procname $args');
	if(-is64 $1 && barch($1) eq "x86")
	{
		berror($1, "Unable to run this BOF properly when under WOW64 (32bit proc on 64bit host)");
		return;
	}
	if(size(@_) > 3 || size(@_) < 2){
		berror($1, "Invalid number of arguments");
		berror($1, beacon_command_detail("findLoadedModule"));
		return;
	}
	$modname = $2;
	$procname = iff(-istrue $3, $3, "");
	$args = bof_pack($1, "zz", $modname, $procname);
	beacon_inline_execute($1, readbof($1, "findLoadedModule", $null, $null), "go", $args);
}

beacon_command_register(
	"findLoadedModule",
	"Finds processes loading a specific dll",
	"Usage:
	findLoadedModule <part dll name> [opt: part proc name]
	
	Searches are done in *<part>* manner, so partial matches will hit
	If you specify a proc name then only processes matching that partial hit will be searched"
);


alias adcs_enum{
	local('$args');

	$domain = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $domain);

	beacon_inline_execute($1, readbof($1, "adcs_enum", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum",
	"Enumerates CAs and templates in the AD using Win32 functions",
	"
Command: adcs_enum
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using
         undocumented Win32 functions. It displays basic information as well 
         as the CA cert, flags, permissions, and similar information for the 
         templates.
Usage:   adcs_enum (domain)
		 domain		Optional. Specified domain otherwise uses current domain.
"
);


alias adcs_enum_com{
	local('$args');

	$args = $null;
	beacon_inline_execute($1, readbof($1, "adcs_enum_com", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum_com",
	"Enumerates CAs and templates in the AD using ICertConfig COM object",
	"
Command: adcs_enum_com
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using 
         the ICertConfig, ICertRequest, and IX509CertificateTemplate COM 
         objects. It displays basic information as well as the CA cert, flags, 
         permissions, and similar information for the templates.
Usage:   adcs_enum_com
"
);


alias adcs_enum_com2{
	local('$args');

	$args = $null;
	beacon_inline_execute($1, readbof($1, "adcs_enum_com2", $null, $null), "go", $args);
}

beacon_command_register(
	"adcs_enum_com2",
	"Enumerates CAs and templates in the AD using IX509PolicyServerListManager COM object",
	"
Command: adcs_enum_com2
Summary: This command enumerates the certificate authorities and certificate 
         types (templates) in the Acitive Directory Certificate Services using 
         the IX509PolicyServerListManager, IX509PolicyServerUrl, 
         IX509EnrollmentPolicyServer, ICertificationAuthority, and 
         IX509CertificateTemplate COM objects. It displays basic information as
         well as the CA cert, flags, permissions, and similar information for
         the templates.
Usage:   adcs_enum_com2
"
);

alias vssenum{
	local('$hostname $sharename $args');
	if (size(@_) < 2)
	{
		berror($1, "Invalid number of arguments");
		berror($1, beacon_command_detail("vssenum"));
		return;
	}

	$hostname = $2;
	$sharename = iff(-istrue $3, $3, "C$");
	$args = bof_pack($1, "ZZ", $hostname, $sharename);
	blog($1, $hostname);
	beacon_inline_execute($1, readbof($1, "vssenum", $null, $null), "go", $args);			# backups and snapshots are referenced but not discovery

}



beacon_command_register(
	"vssenum",
	"Enumerate snapshots on a remote machine",
"Command: vssenum
If the target machine has volume snapshots this command will list there timestamps
This command will likely only work on windows server 2012 + with specific configurations
see https://techcommunity.microsoft.com/t5/storage-at-microsoft/vss-for-smb-file-shares/ba-p/425726 for more info

Usage: vssenum [hostname] (opt: sharename)

sharename defaults to C$ if not specified"
);

alias get_password_policy
{
	local('$server $args');

	if(size(@_) < 2)
	{
		berror($1, "Invalid number of arguments, must specify target server / DC");
		berror($1, beacon_command_detail("get_password_policy"));
		return;
	}
	$server = $2;
	$args = bof_pack($1, "Z", $server);
	beacon_inline_execute($1, readbof($1, "get_password_policy", $null, "T1201"), "go", $args);
}

beacon_command_register(
	"get_password_policy",
	"gets a server or DC's configured password policy",
	"Command: get_password_policy
Basically re-implements net accounts excluding calling out Computer role
If you target a DC with this it will be domain policies, otherwise its the policy for that local server
target \"\" for the local computer

Usage: get_password_policy [hostname]"
);

alias probe
{
	local('$host $port $args $portint');

	if(size(@_) < 3)
	{
		berror($1, "usage: probe <host> <port>");
		return;
	}
	$host = $2;
	$port = $3;
	$portint = parseNumber($port, 10);
	if ($portint < 1 || $portint > 65535) {
		berror($1, "usage: probe <host> <port>");
		berror($1, "Port out of range");
		return;
	}

	$args = bof_pack($1, "zi", $host, $port);
	beacon_inline_execute($1, readbof($1, "probe", $null, "T1046"), "go", $args);
}

beacon_command_register(
	"probe",
	"Check if a port is open",
	"Command: probe

Usage: probe <host> <port>"
);

alias list_firewall_rules
{
	beacon_inline_execute($1, readbof($1, "list_firewall_rules"), "go",  $null);
}

beacon_command_register(
	"list_firewall_rules",
	"List all windows firewall rules",
	"Command: list_firewall_rules

Usage: list_firewall_rules"
);

alias netloggedon{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netloggedon", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"netloggedon",
	"Returns users logged on the local (or a remote) machine - administrative rights needed",
	"netloggedon <\\computername>"
);

alias netloggedon2{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netloggedon2", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"netloggedon2",
	"Returns users logged on the local (or a remote) machine via NetWkstaUserEnum- administrative rights needed. Output is compatible with bofhound",
	"Usage: netloggedon2 <opt: computername>
	
Note: Output from this BOF is compatible with bofhound"
);

alias netuptime{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Zi", $name, 0);
	beacon_inline_execute($1, readbof($1, "netuptime", $null, "T1082"), "go", $args);
}

beacon_command_register(
	"netuptime",
	"Returns information about the boot time on the local (or a remote) machine",
	"netuptime <\\computername>"
);


alias nettime{
	local('$args $name')
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "Z", $name);
	beacon_inline_execute($1, readbof($1, "nettime", $null, "T1082"), "go", $args);
}

beacon_command_register(
	"nettime",
	"Returns information about the current time on a remote (or local) machine. ",
		"
Command: nettime
Summary: This command displays the current time on a remote host. 
Usage:   enum_filter_driver <target>
         Ex: nettime target 
         nettime target.domain.local 
         nettime  

Note:    nettime will return the time of the localhost if target is null
"
);

alias regsession{
	local('$args $name');
	$name = iff(-istrue $2, $2, "");
	$args = bof_pack($1, "z", $name);
	beacon_inline_execute($1, readbof($1, "regsession", $null, "T1049"), "go", $args);
}

beacon_command_register(
	"regsession",
	"Returns users logged on the local (or a remote) machine via the registry - administrative rights needed. Output is compatible with bofhound",
	"Usage: regsession <opt: computername>
	
Note: Output from this BOF is compatible with bofhound"
);

alias aadjoininfo {
	beacon_inline_execute($1, readbof($1, "aadjoininfo", $null, "T1082"), "go", $null);
}

beacon_command_register (
	"aadjoininfo",
	"Retrieve Azure AD/Entra ID join information",
	"Usage: aadjoininfo"
);

alias get_session_info{
	beacon_inline_execute($1, readbof($1, "get_session_info"), "go", $null);
}

beacon_command_register(
	"get_session_info",
	"Returns the auth package, logon server, and current session id of the user you are operating as",
	"Usage: get_session_info"
);

alias ldapsecuritycheck {
	local('$args $dc');

	# Optional argument: DC hostname or IP
	$dc = iff(-istrue $2, $2, "");

	$args = bof_pack($1, "Z", $dc);
	beacon_inline_execute($1, readbof($1, "ldapsecuritycheck", $null, "T1018"), "go", $args);
}

beacon_command_register(
	"ldapsecuritycheck",
	"Check LDAP signing and LDAPS channel binding requirements",
	"Command: ldapsecuritycheck
Summary: This command checks whether the target domain controller requires LDAP
         signing for unencrypted connections and LDAPS channel binding for
         encrypted connections. It performs authentication attempts to detect
         these security requirements.
Usage:   ldapsecuritycheck [dc]
         dc    Optional. Domain Controller hostname or IP to test.
               Auto-discovered if not provided.
         The LDAP SPN is automatically set to ldap/<dc>.
Examples:
         ldapsecuritycheck
         ldapsecuritycheck dc01.domain.local

Note: This command will generate Event ID 2889 on the target DC when LDAP
      signing is required but not used."
);
